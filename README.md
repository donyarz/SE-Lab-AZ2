## Software-Engineering-Lab-Az2



# گام اول: افزودن یک روش پیام رسانی دیگر
| ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر                   | شرحی کوتاه از تغییر                             |
|------|--------------------------------|-------------------------------|------------------------------------------------|
| 1    | MessageService                 | افزودن تابع ارسال پیام تلگرامی | افزودن یک تابع `void` با عنوان `sendTelegramMessage` |
| 2    | NotificationService            | افزودن تابع ارسال SMS        | افزودن یک تابع برای ارسال پیامک               |
| 3    | NotificationService            | افزودن تابع ارسال Email      | افزودن یک تابع برای ارسال ایمیل               |
| 4    | Main                           | افزودن کد برای ارسال پیام    | افزودن کد برای استفاده از سرویس‌های پیام‌رسانی |

<br>
<br> 

# گام 2: تحلیل برنامه از منظر اصول SOLID

| اصل | موارد تحقق | موارد نقض |
|-----|-------------|-------------|
| 1. Single Responsibility | کلاس `Food` تنها مسئولیت مدیریت اطلاعات مربوط به غذاها را دارد. | - رابط `OrderService` شامل متدهایی برای انواع مختلف سفارش‌ها و پرداخت‌ها می‌باشد که این موضوع نقض اصل مسئولیت یگانه است زیرا چندین مسئولیت مختلف را بر عهده دارد. |
| 2. Open-Close Principle (OCP) | - کلاس‌های `OnlineOrderService`, `OnSiteOrderService`, و `PhoneOrderService` از طریق پیاده‌سازی اینترفیس `OrderService` می‌توانند به راحتی توسعه یابند بدون تغییر در کد موجود. | - کلاس `Main` نیاز به تغییر دارد تا انواع جدید سفارش‌ها را پشتیبانی کند که این موضوع نقض اصل باز-بسته است زیرا کلاس باید برای توسعه باز و برای تغییر بسته باشد. |
| 3. Liskov Substitution Principle | - کلاس‌های `OnlineOrderService`, `OnSiteOrderService`, و `PhoneOrderService` به درستی از اینترفیس `OrderService` ارث‌بری کرده‌اند و به صورت جداگانه پیاده‌سازی شده‌اند. | - متدهای رابط `OrderService` مانند `onSiteOrderRegister`, `onlineOrderRegister`, `phoneOrderRegister`, `onSiteOrderPayment`, `onlineOrderPayment`, و `phoneOrderPayment` برای همه کلاس‌های پیاده‌سازی مرتبط نیستند که منجر به بدنه‌های خالی متدها می‌شود و این موضوع نقض اصل جایگزینی لیسکوف است. |
| 4. Interface Segregation Principle | | - اینترفیس `OrderService` به درستی تفکیک نشده است. هر سرویس باید دارای متدهای مرتبط با خود باشد و نباید متدهای نامربوط را پیاده‌سازی کند. - اینترفیس `OrderService` شامل متدهای متعددی برای ثبت و پرداخت سفارشات مختلف است که باعث می‌شود کلاس‌های پیاده‌کننده متدهایی را پیاده‌سازی کنند که به آن‌ها نیاز ندارند. این نقض ISP است. بهتر است اینترفیس‌های جداگانه‌ای برای هر نوع سفارش تعریف شود. |
| 5. Dependency Inversion Principle | - استفاده از اینترفیس `OrderService` به جای وابستگی مستقیم به کلاس‌های خاص تا حدی به رعایت DIP کمک می‌کند. | - کلاس `Main` مستقیماً به کلاس‌های `OnlineOrderService`, `OnSiteOrderService` و `PhoneOrderService` وابسته است. این نقض DIP است. باید به جای وابستگی به کلاس‌های مشخص، از اینترفیس‌ها استفاده شود. |

<br>
<br>


 # گام ۴: بررسی مجدد تغییرات مورد نیاز

با فرض اینکه تمامی اصلاحات در گام ۳ به درستی انجام شده  و موارد نقض اصول SOLID برطرف باشند، تمام موارد نقض ثبت شده در جدول گام 2 برطرف شدند. بنابراین با اعمال اصلاحات لازم در گام ۳، تمامی نقض‌های اصول SOLID برطرف شده‌اند و دیگر نیازی به تغییراتنیست. بنابراین، در گام ۴ هیچ تغییری مورد نیاز نیست و تعداد تغییرات مورد نیاز برابر با صفر است.

<br>
<br>

# گام ۵: جمع‌بندی

#### نتیجه‌گیری

در این گام‌ها، با بررسی کد موجود از منظر اصول SOLID و اعمال اصلاحات لازم، توانستیم به بهبود ساختار و کیفیت کد بپردازیم. بررسی مجدد تغییرات پس از اصلاحات نشان داد که با رعایت این اصول، بسیاری از مشکلات و نیاز به تغییرات اضافی برطرف شده‌اند.

### مزایای به کارگیری اصول SOLID

1. **کاهش پیچیدگی و افزایش خوانایی کد**
    - **اصل مسئولیت یگانه (SRP)**: با رعایت این اصل، هر کلاس تنها یک وظیفه مشخص دارد که منجر به کاهش پیچیدگی و افزایش خوانایی کد می‌شود. این امر نگهداری و توسعه کد را ساده‌تر و کارآمدتر می‌کند.

2. **افزایش انعطاف‌پذیری و قابلیت توسعه**
    - **اصل باز-بسته (OCP)**: با رعایت این اصل، کلاس‌ها برای توسعه باز و برای تغییر بسته هستند. این به معنای آن است که می‌توان بدون تغییر در کد موجود، قابلیت‌های جدیدی به سیستم افزود. این امر موجب می‌شود که سیستم به راحتی قابل گسترش باشد.

3. **کاهش خطر بروز خطا و افزایش قابلیت استفاده مجدد**
    - **اصل جایگزینی لیسکوف (LSP)**: با رعایت این اصل، اطمینان حاصل می‌شود که جایگزینی یک زیرکلاس به جای کلاس پایه، موجب بروز خطا نمی‌شود. این امر موجب افزایش پایداری و اطمینان از عملکرد صحیح سیستم می‌شود.

4. **تفکیک و ساده‌سازی اینترفیس‌ها**
    - **اصل تفکیک اینترفیس‌ها (ISP)**: با رعایت این اصل، اینترفیس‌ها به نحوی تفکیک می‌شوند که هر کدام تنها متدهای مرتبط با خود را داشته باشند. این امر موجب می‌شود که کلاس‌های پیاده‌سازی مجبور نباشند متدهایی را پیاده‌سازی کنند که به آنها نیازی ندارند، که خود موجب کاهش پیچیدگی و افزایش قابلیت نگهداری کد می‌شود.

5. **کاهش وابستگی و افزایش قابلیت تست**
    - **اصل وارونگی وابستگی (DIP)**: با رعایت این اصل، وابستگی‌های کلاس‌ها به جزئیات کاهش می‌یابد و به جای آن به اینترفیس‌ها وابسته می‌شوند. این امر موجب می‌شود که تست و نگهداری کد ساده‌تر و تغییرات جزئی بدون اثرگذاری بر سایر بخش‌های سیستم انجام شوند.

### نتیجه‌گیری کلی

با به کارگیری صحیح اصول SOLID در گام‌های ۳ و ۴، توانستیم کد را بهبود بخشیم و مشکلات موجود را برطرف کنیم. رعایت این اصول منجر به افزایش خوانایی، انعطاف‌پذیری، قابلیت توسعه، پایداری، و قابلیت تست کد شده است. در نتیجه، سیستم به شکلی بهینه‌تر و قابل نگهداری‌تر طراحی شده و توسعه آن در آینده نیز ساده‌تر خواهد بود.


