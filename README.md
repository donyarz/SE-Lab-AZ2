## Software-Engineering-Lab-Az2



# گام اول: افزودن یک روش پیام رسانی دیگر
| ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر                   | شرحی کوتاه از تغییر                             |
|------|--------------------------------|-------------------------------|------------------------------------------------|
| 1    | MessageService                 | افزودن تابع ارسال پیام تلگرامی | افزودن یک تابع `void` با عنوان `sendTelegramMessage` |
| 2    | NotificationService            | افزودن تابع ارسال SMS        | افزودن یک تابع برای ارسال پیامک               |
| 3    | NotificationService            | افزودن تابع ارسال Email      | افزودن یک تابع برای ارسال ایمیل               |
| 4    | Main                           | افزودن کد برای ارسال پیام    | افزودن کد برای استفاده از سرویس‌های پیام‌رسانی |

<br>
<br> 

# گام 2: تحلیل برنامه از منظر اصول SOLID

| اصل | موارد تحقق | موارد نقض |
|-----|-------------|-------------|
| 1. Single Responsibility | کلاس `Food` تنها مسئولیت مدیریت اطلاعات مربوط به غذاها را دارد. | - رابط `OrderService` شامل متدهایی برای انواع مختلف سفارش‌ها و پرداخت‌ها می‌باشد که این موضوع نقض اصل مسئولیت یگانه است زیرا چندین مسئولیت مختلف را بر عهده دارد. |
| 2. Open-Close Principle (OCP) | - کلاس‌های `OnlineOrderService`, `OnSiteOrderService`, و `PhoneOrderService` از طریق پیاده‌سازی اینترفیس `OrderService` می‌توانند به راحتی توسعه یابند بدون تغییر در کد موجود. | - کلاس `Main` نیاز به تغییر دارد تا انواع جدید سفارش‌ها را پشتیبانی کند که این موضوع نقض اصل باز-بسته است زیرا کلاس باید برای توسعه باز و برای تغییر بسته باشد. |
| 3. Liskov Substitution Principle | - کلاس‌های `OnlineOrderService`, `OnSiteOrderService`, و `PhoneOrderService` به درستی از اینترفیس `OrderService` ارث‌بری کرده‌اند و به صورت جداگانه پیاده‌سازی شده‌اند. | - متدهای رابط `OrderService` مانند `onSiteOrderRegister`, `onlineOrderRegister`, `phoneOrderRegister`, `onSiteOrderPayment`, `onlineOrderPayment`, و `phoneOrderPayment` برای همه کلاس‌های پیاده‌سازی مرتبط نیستند که منجر به بدنه‌های خالی متدها می‌شود و این موضوع نقض اصل جایگزینی لیسکوف است. |
| 4. Interface Segregation Principle | | - اینترفیس `OrderService` به درستی تفکیک نشده است. هر سرویس باید دارای متدهای مرتبط با خود باشد و نباید متدهای نامربوط را پیاده‌سازی کند. - اینترفیس `OrderService` شامل متدهای متعددی برای ثبت و پرداخت سفارشات مختلف است که باعث می‌شود کلاس‌های پیاده‌کننده متدهایی را پیاده‌سازی کنند که به آن‌ها نیاز ندارند. این نقض ISP است. بهتر است اینترفیس‌های جداگانه‌ای برای هر نوع سفارش تعریف شود. |
| 5. Dependency Inversion Principle | - استفاده از اینترفیس `OrderService` به جای وابستگی مستقیم به کلاس‌های خاص تا حدی به رعایت DIP کمک می‌کند. | - کلاس `Main` مستقیماً به کلاس‌های `OnlineOrderService`, `OnSiteOrderService` و `PhoneOrderService` وابسته است. این نقض DIP است. باید به جای وابستگی به کلاس‌های مشخص، از اینترفیس‌ها استفاده شود. |

<br>
<br>


 # گام ۴: بررسی مجدد تغییرات مورد نیاز

با فرض اینکه تمامی اصلاحات در گام ۳ به درستی انجام شده  و موارد نقض اصول SOLID برطرف باشند، تمام موارد نقض ثبت شده در جدول گام 2 برطرف شدند. بنابراین با اعمال اصلاحات لازم در گام ۳، تمامی نقض‌های اصول SOLID برطرف شده‌اند و دیگر نیازی به تغییراتنیست. بنابراین، در گام ۴ هیچ تغییری مورد نیاز نیست و تعداد تغییرات مورد نیاز برابر با صفر است.


